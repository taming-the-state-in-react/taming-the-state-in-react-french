# Introduction

La gestion de l'état au sein des applications est devenu un sujet populaire ces dernières années. Les *Single Page Applications* (SPAs) - sont délivrées seulement une fois par un serveur web et restent intéractif côté client - doivent établir une gestion d'état côté client. Ils doivent conserver l'état cohérent sans faire de requêtes supplémentaires auprès du backend. Ils doivent fournir à l'utilisateur une expérience plaisante et aisée lors de l'utilisation de l'application. Cela démarre dès al simple ouverture d'un pop-up dans votre application. Quelqu'un a besoin d'être aux prises avec cet état. Mais qui gère cet état si ce n'est pas le backend?

jQuery était une bibliothèque populaire avant que les premières solutions SPAs apparurent tel qu'Angular, Ember et Backbone. La gestion de l'état en lui-même n'était pas un immense problème au tout début de jQuery, car la bibliothèque était la plupart du temps seulement utilisée pour de sélectives manipulations de DOM. Vous pouviez ajouter des animations à votre HTML, ajouter ou supprimer des noeuds de DOM ou bien changer le style de votre HTML de façon programmatique. Cela rendait  les applications web plus agréables en les rendant plus interactive.

Finalement, le code jQuery, et de manière générale la proportion du code JavaScript comparé à celui de l'HTML et du CSS a grandi, et beaucoup de personnes écrivirent des applications frontend beaucoup plus sophistiquées. La plupart du temps, cela se terminait par un code jQuery en bazar où pas seulement la gestion de l'état était un problème, mais aussi les bonnes pratiques en générales comme le manque de nettoyage du code. Il n'y avait pas de solution d'architecture générale pour ces types d'applications frontend et les personnes luttaient pour le garder maintenable dans de plus grandes applications.

Au bout d'un moment, les solutions de *Single Page Applications* (SPA) telles qu'Angular, Ember et Backbone émergèrent pour fournir à ces applications frontends non structurées un framework à proprement parler. La plus grande partie des SPAs sont construites sur le patron de conception modèle-vue-contrôleur (MVC) dans le but d'architecturer l'application. Ces frameworks contiennent tout ce dont vous auriez besoin, depuis la couche vue pour l'affichage de l'HTML au sein du browser jusqu'à la couche modèle pour l'interaction avec votre backend, pour construire votre application complexe. Le terme SPA a été formulé, car ces applications sont fournies une seule fois par le backend, comme page unique, et ensuite gérées seulement côté client. Il y a des morceaux d'HTML liés avec du JavaScript qui contiennent tout ce dont les applications ont besoin pour fonctionner côté client. Lors de la navigation vers une page différente sous une URL différente, il n'y a aucune requête serveur requise pour aller chercher l'HTML à l'aide du JavaScript. Les SPAs intrargissent avec le backend pour envoyer ou réceptionner de nouvelles données. Ils interagissent seulement avec le backend pour récupérer ou envoyer de nouvelles données. Ainsi, la seule chose qui change c'est l'état au sein de l'application côté client, car les donnés sont lus et écrits depuis et auprès du backend et les interactions telles que les pop-ups, filtres et modals doivent fonctionner. Mais qui gère cet état dans le but de conserver un côté client cohérent?

Même si ces solutions pour une première génération de SPAs mettent en place les bonnes pratiques, patrons de conception et architectures, la gestion de l'état devint un problème récurrent. Lors de l'interaction avec le backend pour retrouver de nouvelles données, la façon de gérer les données de manière prédictible n'était pas tout à fait claire. Lors du déclenchement de la vue relié aux éléments, tel que les modales et pop-ups, côté client, souvent aucune bonne pratique n'était établie pour gérer ces états. Tous les frameworks essayèrent d'appliquer leurs propres solutions pour cela. Finalement, les personnes imaginèrent leurs propres bonnes pratiques et bibliothèques, mais ne devinrent jamais de prédictible et cohérente expérience pour gérer l'état à l'aide de contraintes évidentes.

Il y avait un défaut majeur avec ces solutions SPA qui conduisaient en premier lieu à ce problème : en tant que framework, ils essayaient de résoudre trop de problèmes en une seule fois. Parcequ'ils étaient la première vague, ils n'avaient aucune chance de résoudre tous les problèmes liés au monde des SPAs. Finalement, ils résolurent ces problèmes dans de futures itérations lorsque d'autres solutions SPA apparurent sur le devant de la scène.

La seconde génération de solutions SPA, avec parmi elles des bibliothèques telles que React et Vue, ce sont concentrées seulement sur de plus petites parties de l'application. Elles se sont concentrées sur la couche vue. Il appartenait aux ingénieurs de décider de futures bibliothèques en tant que solutions pour des problèmes spécifiques. [C'est ce qui a fait de React une bibliothèque si puissante dès ses débuts](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/), car tout le monde peut décider d'étendre l'application à l'aide de bibliothèques qui résout de problèmes certes petits mais spécifiques.

De nos jours, une multitude d'articles et bibliothèques essayent de résoudre le problème de la gestion d'état. C'est difficile de trouver chaussure à son pied comme source de vérité cohérente pour apprendre la gestion d'état au sein des applications modernes. Même si, les solutions telles que React disposent de leur propre implémentation de gestion d'état pour des états locaux au sein des composants, là les solutions sont plus externes arrivant avec des bibliothèques telles que Redux et MobX qui établissent de la gestion d'état complexe.

Il manque encore un guide pour appréhender toutes ces différentes solutions pour éclaircir toutes les différences et avantages. Assez souvent, les guides oublient le fait d'enseigner le problème à résoudre avant tout chose. De plus, au lieu de dévoiler l'approche minimale, ils essayent de réparer le problème de la gestion d'état en utilisant des approches usine à gaz (*over-engineered*). Mais cela peut être tellement plus aisé. Il suffit seulement d'une seule ressource pour être guider au travers de la gestion d'état au sein d'applications modernes et ceux dans une démarche constructive et cohérente. C'est la mission de ce livre.

Si vous voulez apprendre quelque chose, vous devez le faire étape par étape. En essayant de résoudre chaque problème atomiquement les uns après les autres. N'appliquez pas tous d'un seul coup. Comprenez le problème et résolvez-le. C'est mon essai avec ce livre : il n'apprend pas seulement Redux au sein de React, mais la gestion d'état dans les applications modernes. Il va au-delà de la documentation des bibliothèques de gestion d'état, mais applique directement les acquis du livre avec des applications réelles et effectives.

Le livre a pour fil rouge la gestion d'état dans les applications modernes. Il débute avec la gestion d'états locaux au sein d'une bibliothèque pour la couche vue (React), il met en exergue les problèmes inhérents au sein de larges applications et a pour volonté de guider vers des solutions de gestion d'état complexe tel que Redux et MobX. Au cours de votre lecture du livre, vous trouverez du code de mise en situation qui illustre les problèmes et solutions. Je vous encourage à vous amuser avec ces exemples de mise en situation afin d'acquérir une expérience applicable.  Vous pouvez même essayer d'appliquer ces bouts de code dans votre IDE et vous amuser avec. Mais ne vous inquiétez pas si vous ne trouvez pas de solution au début. Vous serez guidé dans divers chapitres par mes soins pour appliquer vos acquis dans votre IDE. Cependant, n'hésitez pas à vérifier vos acquis au plus tôt.

Ce sont les protagonistes du livre : Local State (dans React), Redux et MobX. Il n'aurait pas été possible d'écrire ce livre sans les innovateurs derrière ces solutions : [Dan Abramov](https://twitter.com/dan_abramov), [Andrew Clark](https://twitter.com/acdlite) et [Michel Weststrate](https://twitter.com/mweststrate). Naturellement, je ne peux que les remercier au nom de toute la communauté pour leurs efforts de rendre de la gestion d'état, une expérience cohérente et agréable au sein des applications modernes.
